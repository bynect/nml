(* An implementation of lists *)

data List a = Cons : a * List a | Nil

fun cons x xs : a -> List a -> List a = Cons (x, xs)

fun head xs : List a -> a =
  match xs with
  | Cons (x, _) -> x
  | Nil -> panic "List.head with Nil"

fun tail xs : List a -> List a =
  match xs with
  | Cons (_, xs) -> xs
  | Nil -> panic "List.tail with Nil"

fun length xs : List a -> Int  =
  fun length' acc xs =
    match xs with
    | Cons (_, xs) -> length' (acc + 1) xs
    | Nil -> acc
  in
  length' xs 0

fun last xs : List a -> a =
  match xs with
  | Cons (x, Nil) -> x
  | Cons (_, xs) -> last xs
  | Nil -> panic "List.last with Nil"

fun map f xs : (a -> b) -> List a -> List b =
  match xs with
  | Cons (x, xs) -> Cons (f x, map f xs)
  | Nil -> Nil

fun foldr f acc xs : (a -> b -> b) -> b -> List a -> b =
  match xs with
  | Cons (x, xs) -> f x (foldr f acc xs)
  | Nil -> acc

fun foldl f acc xs : (a -> b -> a) -> a -> List b -> a =
  match xs with
  | Cons (x, xs) -> foldl f (f acc x) xs
  | Nil -> acc

let reverse : List a -> List a = foldl (\a b -> Cons (b, a)) Nil

fun append xs ys =
  match xs with
  | Cons (x, xs) -> Cons (x, append xs ys)
  | Nil -> ys

fun concat xs =
  match xs with
  | Cons (x, xs) -> append x (concat xs)
  | Nil -> Nil

fun zip xs ys : List a -> List b -> List (a * b) =
  match xs, ys with
  | Cons (x, xs), Cons (y, ys) -> Cons ((x, y), zip xs ys)
  | _, _ -> Nil

fun zip' f xs ys : (a -> b -> c) -> List a -> List b -> List c =
  match xs, ys with
  | Cons (x, xs), Cons (y, ys) -> Cons (f x y, zip' f xs ys)
  | _, _ -> Nil

fun unzip xs : List (a * b) -> List a * List b =
  fun unzip' x y =
    match x, y with
    | (xs, ys), (x, y) ->
      Cons (x, xs), Cons (y, ys)
  in
  foldr unzip' (Nil, Nil) xs

fun filter f xs : (a -> Bool) -> List a -> List a =
  match xs with
  | Cons (x, xs) ->
    if f x then Cons (x, filter f xs)
    else filter f xs
  | Nil -> Nil

fun find f xs : (a -> Bool) -> List a -> Option a =
  match xs with
  | Cons (x, xs) ->
    if f x then Some x
    else find f xs
  | Nil -> None

fun index xs n : List a -> Int -> a =
  fun index' xs n =
    match xs with
    | Cons (x, xs) ->
      if n = 0 then x
      else index' xs (n - 1)
    | Nil -> panic "List.index with invalid n"
  in
  if n < 0 then panic "List.index with invalid n"
  else index' xs n

data Order = Lt | Gt | Eq

fun merge f xs ys : (a -> a -> Order) -> List a -> List a -> List a =
  match xs, ys with
  | Nil, ys -> ys
  | xs, Nil -> xs
  | Cons (x, xs'), Cons(y, ys') ->
    if f x y = Gt then Cons (y, merge f xs ys')
    else Cons (x, merge f xs' ys)
